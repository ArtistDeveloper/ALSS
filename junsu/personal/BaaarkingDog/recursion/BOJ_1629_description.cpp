//#include <iostream>
//
//using namespace std;
//
//using ll = long long;
//
//// 2의 승수를 구하는 코드
//ll pow(int a, int b, int m)
//{
//	if (b == 1) return a;
//	ll val = pow(a, b / 2, m);
//
//	if (b % 2 == 1) return val * val * a;
//	return val * val;
//}
//
//int main()
//{
//	int a, b, mod;
//	cin >> a >> b >> mod;
//
//	cout << pow(a, b, mod);
//
//	return 0;
//}

#include <iostream>

using namespace std;

using ll = long long;


// ||목표||
// (a^b) % m 을 구하는 것이 문제의 목표이다.
// 그러나 a^b를 구하는 과정에서 long long에서도 overflow가 발생할 수 있다.
// 그래서 모듈러의 합동공식을 통해 overflow가 발생하지 않으며 결과도 "(a^b) % m"의 값과 같을 수 있도록 만든다.


// ||pow함수의 return 값에 대해 알아보자.||
// -> 재귀를 통해 제일 처음 return되는 val의 값은 a이다. (ll val = a;) 즉, 밑의 값이라는 소리인데 이것은 base condition에 의해 반환되는 값이다.
// -> "b == 1" 이라는 조건은 지수가 1일 때이다. 그렇기에 밑의 값을 그대로 return하는 것이다.
// --> 한 번 base condition에 진입한 이후로는 base condition에 진입할 일이 없어지는데, 
// --> base condition이후에 val의 값은 단순 밑이 아니라 지수법칙을 이용하여 구해지는 a(밑)의 제곱된 값이다.
// 
// --> 그 뒤에는 b(지수)가 짝수냐 홀수냐에 따라 반환되는 값이 달라진다. 
// --> 짝수: return val * val
// --> 홀수: return val * val * a
// 
// --> 짝수의 return값의 대한 설명: 
// ---> 지수법칙을 사용하면 10^2의 값을 구하려면 단순히 10*10을 하면된다. ("10^1 * 10^1 = 10^2"이기 때문.)
// ---> 10^4 을 구한다고 치면 [10^2 * 10^2 = 10^4] 가 된다.
// ---> 즉, 지수가 짝수일 때 pow함수를 통해 return되어 받는 val의 값은 [val * val]이다. val * val을 통해 10^1 * 10^1을 만들어
// ---> 10^2를 만들고 이렇게 만든 vaㅣ = 10^2의 값을 다시 10^4의 값을 만드는데 사용한다.
//
// --> 홀수의 return값의 대한 설명:
// 10^5을 구한다고 가정하면 10^2 * 10^2 * 10^1 = 10^5 처럼 구할 수 있다.
// 그래서 val * val * a를 return하게 된다.
// 
// 정리하자면 다음과 같다.
//  1. base condition에 진입할 때: 밑의 값을 반환한다. 
//  2. b(지수)가 짝수일 때는 [val * val] 값을 반환한다.
//  3. b(지수)가 홀수일 때는 [val * val * a(밑)] 값을 반환한다.


// |return값 수정하기|
// 우리의 목표는 단순히 제곱의 값을 구하는 것이 아니라, 제곱의 값에 나머지 연산까지 한 값을 출력해야 한다.
// 이를 어떻게 수행할 수 있을까? 
// a를 밑으로 둔 b만큼 제곱한 값을 구할 수 있게 되었으니 이 결과값에 주어진 값으로 모듈러 연산을 하면 되지 않을까?
// -> 이렇게 하면 틀리게 된다. 값이 작게 나오는 경우에서는 맞지만, a, b, m의 값이 커지면 overflow가 발생하게 된다.
// -> 어떤 경우에서 overfow가 발생하지 않을까?
// 
// 우선 어떤 경우에서 overflow가 발생하지 않는지를 살펴보기 전에 왜 계산도중에 나머지 연산을 해도 최종결과가 제대로 된 결과가 나오는지 알아야 한다.
// --> 모듈러 연산을 위해 [val * val % c]라는 값을 반환하게 될텐데, 왜 이 값이 결론적으로 제대로 작동된 결과처럼 나올까?
// --> [12^58 % 67 = 4]이다. [12^116 % 67 = 16]이다.
// --> 즉, 12^58 * 12^58 = 12^116이고,
// --> (12^58 % 67) * (12^58 % 67) = 12^116 % 67 이다.
// ---> 그래서 4 * 4 = 16 과 같은 식이 만들어진다. 
// ---> "12^58 % 67" 에서 12^58을 12^29 * 12*29로 치환할 수 있다. 그러면 "12^29 * 12^29 % 67"와 같은 식으로 볼 수 있다.
// ---> 즉, "12^29"은 우리 코드에서 val로 볼 수 있다. 그러면 [val * val % m]으로 일반화해서 생각할 수 있다.
// ---> 그리고 "(12^58 % 67) * (12^58 % 67) = 12^116 % 67" 의 결과는 같다는 것이 증명되어 있으니, 지수를 구하면서 같이 모듈러 연산을 해도 
// ---> 귀납적으로 최종결과의 모듈러 연산값이 맞다고 생각할 수 있다. 
// 
// 결론은 각 depth마다의 val * val % c의 값을 받아서 계산한 것이 a^b % m 을 한 것과 값이 같다는 소리이다.
// 
// 그럼 이제 어느 경우에서 overlfow가 생기는지 살펴보자.
// -> 지수가 짝수인 경우: val * val % c 값이 반환된다. 여기서 overflow가 발생할까?
// --> 우선 a, b, c 모두 int 타입의 값이고 int의 최대값은 2^31 - 1이다. val의 type은 long long으로 선언해두었다.
// --> a(밑)의 최대 값은 2^31 - 1이고, b(지수)의 최대 값도 2^31 - 1이다.
// --> 그래서 만약 (2^31 - 1) * (2^31 - 1) * (2^31 - 1) 정도만 수행해도 long long을 아득히 넘어버린다.
// --> 그래서 우리는 계산 중간중간에 나머지 연산을 섞어 val * val % m을 수행한다.
// --> 이처럼 수행하면 결과값을 return 받는 val에서는 어차피 나머지 연산이 수행되어 오기에 값이 overflow될 일은 없다.
// --> 그럼 하나를 더 확인하자면 val * val % m 을 할때 overflow가 초과하지 않는지만 살펴보면 되는데,
// --> (2^31 - 1) * (2^31 - 1) < 2^63 -1
// --> 위처럼 val * val을 계산해도 long long 범위안에 있기에 overlfow가 발생하지 않는다. 
// --> (나머지 연산 안섞으면 당연히 오버플로우 발생가능.)
//
// -> 지수가 홀수인 경우: (val * val * a) % c의 값을 반환해보자.
// --> val * val * a 을 수행할 때 val을 (2^31 - 1)으로 가정하고, 밑인 a도 (2^31 - 1)로 가정해보자.
// --> 그렇다면 val * val * a에서는 숫자가 커지면 무조건 overflow가 발생한다는 소리이다. (2^31 -1) * (2^31 -1) * (2^31 -1) == 2^94 (근사값)
// --> 그러면 val * val을 계산한 뒤에 * a를 곱하기전에 모듈러 연산을 한 번 수행해주어야 overflow가 발생할 가능성이 사라지는데, 
// --> 이 때 사용하는 것이 모듈러의 합동공식이다.


// 우선 모듈러의 합동공식은 (A * B) % C = (A % C * B % C) % C이다.
// 코드의 어떤 값을 위 합동공식의 A와 B에 치환할 수 있을까?
// 합동공식의 A는 코드의 val * val로 치환할 수 있다.
// 합공공식의 B는 코드의 a로 치환할 수 있다. 그렴 다음과 같이 나타낼 수 있다.
//  (val * val * a) % c = ((val * val) % c * (a % c)) % c  || 여기서 (val * val % c) = (val * val % c) % c로 표현할 수 있다.
// = (((val * val % c) % c ) * (a * c)) % c 
// = ((val * val % c) * a) % c

// 최종적으로 홀수의 return 부분에 합동공식을 사용한 것을 넣으면 된다.

ll pow(int a, int b, int m)
{
	/*if (b == 1) return a % m; 
	ll val = pow(a, b / 2, m);

	if (b % 2 == 1) return (val * val % m) * a % m;
	return (val * val) % m;*/

	// 수식을 간추려서 좀 더 생략해서 풀자면 이렇게 표현할 수도 있다.
	if (b == 1) return a % m;
	ll val = pow(a, b / 2, m);

	val = val * val % m;

	if (b % 2 == 1) return val * a % m;
	return val;
}

int main()
{
	int a, b, mod;
	cin >> a >> b >> mod;

	cout << pow(a, b, mod);

	return 0;
}
